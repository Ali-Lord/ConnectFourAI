def is_valid_location(board, col):
	return board[ROW_COUNT-1][col] == 0
  
def get_valid_locations(board):
	valid_locations = []
	for col in range(COLUMN_COUNT):
		if is_valid_location(board, col):
			valid_locations.append(col)
	return valid_locations

def minimax(board, depth, maximizingPlayer):
    valid_locations = get_valid_locations(board)
    if depth == 0:
        if winning_move(board, AI_PIECE):
          return (None, 100)
        elif winning_move(board, PLAYER_PIECE):
          return (None, -100)
        else:
          return (None, 0)
    else:
        return (None, score_position(board, AI_PIECE))
        
    if maximizingPlayer:
      value = -math.inf
      column = random.choice(valid_locations)
      for col in valid_locations:
        row = get_next_open_row(board, col)
        b_copy = board.copy()
        drop_piece(b_copy, row, col, AI_PIECE)
        new_score = minimax(b_copy, depth-1, False)[1]
        if new_score > value:
          value = new_score
          column = col
      return column, value

    else: # Minimizing player
      value = math.inf
      column = random.choice(valid_locations)
      for col in valid_locations:
        row = get_next_open_row(board, col)
        b_copy = board.copy()
        drop_piece(b_copy, row, col, PLAYER_PIECE)
        new_score = minimax(b_copy, depth-1, True)[1]
        if new_score < value:
          value = new_score
          column = col
      return column, value
      
